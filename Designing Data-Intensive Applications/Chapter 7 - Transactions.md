

# ACID

Гарантии, которые дает [[transactions | транзакция]] часто описывают акронимом [[ACID]].

-  **Atomicity**
	 В нашем контекте означат то, что если в процессе совершении транзакции на одной из стадий произойдет ошибка, то все транзакция откатится - вернет данные в исходное состояние.
- **Consistency**
Означает, что заданные нами инварианты обязаны сохраняться после совершения транзакции.
-  **Isolation**
Означает, что параллельно выполняемые транзакции будут изолированы друг от друга.
**Serializability** - гарантия того, что результат паралельных транзакций будет такой же, как если бы они выполнялись последовательно (serial)  - на практике редко делается, так как дорогая по времени.

- **Durablility**
Гарантия того, что успешная транзакция действительно успешна - данные не будут утеряны.
Например в **single-node** бд - запись в лог, в **replicated** бд - сохраниние данных на нескольких нодах

# Single and multi-object requests

Проблемы с **atomicity** и **consistency** проявляются как в **single-object** запросах, так и в **multi-objects**. В запросах первого типа нарушение гарантий может произойти, если изменяем данные большого объема (JSON 20kb), в запросах второго типа все очевидно. Для объединения **multi-object** запросов в одну транзакцию в [[Relational databases | relation databases]] используется **BEGIN TRANSACTION** и **COMMIT** - в [[Document-based databases | document-based databases]] часто такого инструмента НЕТ. **Single-object** запросы позволяют избежать много проблем (i.e: **Lost updates**), но **multi-object** запросы нужны:
- Проверка foreign-keys в [[Relational databases]]
- Обновление [[Denormalized data]] в [[Document-based databases]]
- Обновление индексов

# Isolation guarantees
#### Read commited isolation

Один из базовых уровней **Isolation** - **Read commited**. Гарантирует, что
- Для чтения будут доступны только закомиченные данные (**dirty read**)
- Запросы на запись не перетрут незакомиченные данные (**dirty write**)

**Read commited** дефолтная настройка в [[Oracle]], [[PostgreSQL]]
Однако этот уровень гарантий не защищает от проблемы **Lost Updates**
Отсутствие **dirty writes** достигается простым мьютексом, **dirty reads** тоже можно так фиксить, но на практике не так - при больших объемах запросов на чтение неэффективно. Обычно бд запоминает состояние в начале текущего обладателя мьютекса на запись и отдает на чтение именно это состояние.
#### Snapshot isolation

Есть проблема **read skew** (aka **nonrepeatable read**) - при чтении данных из нескольких объектов в рамках одной транзакции между двумя чтениями может параллельно прилететь транзакция, изменяющая оба объекта. И даже если вторая транзакция сохраняет инвариант между объектами (i.e два числа в сумме дают 100), то для первой транзакции инвариант нарушился. Иногда данная аномалия приемлема. Но она не допустима при создании бэкапа и для больших запросов для аналитики.

Решение - уровень изоляции **Snapshot isolation** (aka **repeatable read**). **Dirty writes** решаются также, как в **read commited** - мьютексы. **Dirty reads** - обобщение метода "хранить несколько версий" - **MVCC** (Multiversion concurrency control). Данные теперь хранятся в нескольких состояниях и каждое состояние имеет id транзакции, которое в это состояние привело. Для решения **read scew** теперь нужно выбрать состояние с нужным id транзакции.

# Lost Update Problem

(Как я понимаю, речь идет про обобщение **dirty write** гарантии и помещено в отдельный case, тк легко набаговать используя [[ORM]])

Эта проблема, связанная с write запросами происходит при **read-modify-write cycle** и заключается в том, что при параллельных запросах такого типа один из **modify** может потеряться (i.e увеличение счетчика на банковском счету). 

Можно решить с помощью atomic-операций (внутри просто ставят мьютекс на данные). При использовании [[ORM]] стоит быть внимательным и следить, чтобы операции были такими. В случае если **modify** слишком сложный или бд не предоставляет atomic-операции приложение должно само сделать явный **lock**. Например в [[Relational databases]] **lock** можно вызвать так - **FOR UPDATE**.

Другое решение - автоматически обнаруживать **lost  update** и делать ретраи. Такая часто работает эффективнее. Например так сделано в [[PostgreSQL | PostgreSQL's]] repeatable read,  [[Oracle | Oracle's]] serializable. [[MySQL]] этой стратегией не пользуется, поэтому считается, что она не выполняет **snapshot isolation**.

В [[Replicated databases]] мьютексы не работают (например в [[Multi-leader]] и [[Leaderless]] имплементациях мьютексы бесмысленны). Тогда применятеся метод хранения нескольких версий с последующим мерджем. Однако частовстречаемая стратегия conflict-resolution [[LWW | LWW (last write wins)]] может допускать **lost update**.

# Write skew problem

Две транзакции прочитали объекты **A** и **B**, проверили что оба объекта не изменены и сделали следущее: первая транзакция изменила объект **A**, вторая - **B**, при этом нарушив инвариант "Нельзя одновременно менять оба объекта". Отличается от **dirty write** и **lost update** тем, что происходит обновление нескольких объектов.

Как я понял решение автора - использовать **serializable isolation**.

# Serializable isolation

Есть простое решение - последовательно выполнять транзакции в одном потоке. Например, так делает [[Redis]].

Важно при этом подходе экномить на количестве запросов к бд рамках одной трансляции (тратится много времени на коммуникацию по сети). Поэтому вместо **interactive multi-statement transactions** используются **stored procedures**. 

Современные процедуры пишутся на современных языках: [[VoltDB]] использует [[Java]], [[Redis]] - [[Lua]]

TODO





***
[[Designing Data-Intensive Applications]]
[[Transactions]]
[[Databases]]