

# ACID
Гарантии, которые дает [[transactions | транзакция]] часто описывают акронимом [[ACID]].

-  **Atomicity**
	 В нашем контекте означат то, что если в процессе совершении транзакции на одной из стадий произойдет ошибка, то все транзакция откатится - вернет данные в исходное состояние.
- **Consistency**
Означает, что заданные нами инварианты обязаны сохраняться после совершения транзакции.
-  **Isolation**
Означает, что параллельно выполняемые транзакции будут изолированы друг от друга.
**Serializаability** - гарантия того, что результат паралельных транзакций будет такой же, как если бы они выполнялись последовательно (serial)  - на практике редко делается, так как дорогая по времени.

- **Durablility**
Гарантия того, что успешная транзакция действительно успешна - данные не будут утеряны.
Например в **single-node** бд - запись в лог, в **replicated** бд - сохраниние данных на нескольких нодах

# Single and multi-object requests
Проблемы с **atomicity** и **consistency** проявляются как в **single-object** запросах, так и в **multi-objects**. В запросах первого типа нарушение гарантий может произойти, если изменяем данные большого объема (JSON 20kb), в запросах второго типа все очевидно. Для объединения **multi-object** запросов в одну транзакцию в [[Relational databases | relation databases]] используется **BEGIN TRANSACTION** и **COMMIT** - в [[Document-based databases | document-based databases]] часто такого инструмента НЕТ. **Single-object** запросы позволяют избежать много проблем (i.e: **Lost updates**), но **multi-object** запросы нужны:
- Проверка foreign-keys в [[Relational databases]]
- Обновление [[Denormalized data]] в [[Document-based databases]]
- Обновление индексов

# Isolation guarantees
#### Read commited isolation

Один из базовых уровней **Isolation** - **Read commited**. Гарантирует, что
- Для чтения будут доступны только закомиченные данные (**dirty read**)
- Запросы на запись не перетрут незакомиченные данные (**dirty write**)
**Read commited** дефолтная настройка в [[Oracle]], [[PostgreSQL]]
Однако этот уровень гарантий не защищает от проблемы **Lost Updates**
Отсутствие **dirty writes** достигается простым мьютексом, **dirty reads** тоже можно так фиксить, но на практике не так - при больших объемах запросов на чтение неэффективно. Обычно бд запоминает состояние в начале текущего обладателя мьютекса на запись и отдает на чтение именно это состояние.
#### Snapshot isolation
Есть проблема **read skew** - при чтении данных из нескольких объектов в рамках одной транзакции между двумя чтениями может параллельно прилететь транзакция, изменяющая оба объекта. И даже если вторая транзакция сохраняет инвариант между объектами (i.e два числа в сумме дают 100), то для первой транзакции инвариант нарушился. Иногда данная аномалия приемлема. Но она не допустима при создании бэкапа и для больших запросов для аналитики.

Решение - уровень изоляции **Snapshot isolation**. **Dirty writes** решаются также, как в **read commited** - мьютексы. **Dirty reads** - обобщение метода "хранить несколько версий" - **MVCC** (Multiversion concurrency control). Данные теперь хранятся в нескольких состояниях и каждое состояние имеет id транзакции, которое в это состояние привело. Для решения **read scew** теперь нужно выбрать состояние с нужным id транзакции.

TODO







***
[[Designing Data-Intensive Applications]]
[[Transactions]]
[[Databases]]