# Ports and Adapters (Hexagonal)

Этот архитектурный стиль основывается на концептуальной разнице между внешними девайсами и самим приложением. Логика прилодение не должна быть завязаннна на этих девайсах. [[Ports and Adapters]] разделяют архитектуру на внутренний и внешний слой. Внешний слой делится на **primary actors** - процедуры и функции, которые вызываются из внешнего мира и **secondary actors** - отвечающие за исходящие во внешний мир запросы, базы данных, плтежные шлюхы (**payment gateways**). 

![[ports_and_adapters.jpg]]

Внутренний слой - само приложение. Преимущества такого подхода очевиды:
- Возможность мокинга компонентов из внешнего слоя.
- Независимость приложения от технологий внешнего слоя.
- Возможность независимого теста обоих слоев.
Значительных минусов авторы не приводят. 

Внутренний слой может быть устроен по-разному:
- **Service Layer with Transaction Scripts**
	В этом варианте приложение состоит только из **Application Services** и использует такие паттерны как [[Transaction Scripts]], [[Active Record]], [[Data Access Object]] чтобы реализовать [[CRUD]] операции. Доменная моделю в данном случае не применяется.
- **Service Layer with Domain Model**
	Вместе с **Application Services** идет доменная модель. 
(как я понимаю **Service Layer** - это абстракция, которая координирует транзакции, ответы, бизнес-логику между **Application Services** - те как-бы прослойка между ними)
- **Domain Model of Actors**
	Применяется вместе с **message-driven** архитектурами. Грубо говоря - вместо **Application Services** теперь более мелкие, полностью независимые **Actors**. Нет **Service Layer**, потому что теперь взаимодействие происходит посредством **message-broker**'a. Домменная модель может предоставлять "**actor-based Domain Services**".
- **Functional Core with Imperative Shell**
	Пишем бизнес-логику в функциональной парадигме и оборачиваем это дело в **Imperative Shell**. 



![[ports_and_adapters_core.jpg]]
![[table_comp.jpg]]

Смотря на таблицу сравнения хочется использовать либо **Domain Model of Actors**, либо **Functional Core with Imperative Shell**.

# Message- and Event-Driven Architectures

Алььтернативы: [[REST]] и [[RPC]] - пользуются больше популярностью, потому их использование грубо, но напоминает привычные и понятные вызовы методов. Минус данных подходов - [[Coupling]] между запросом и ответом. Например, из-за сетевой ошибки на каком-то этапе весь **client service** упадет. Поэтому используют **asynchronous messaging**.

Есть два основных способа организации процесса при таком подходе: **Choreographed** и **Orchestrated**. Первый - децентрализованный. Например, сообщение о том, что како-ето событие произошло получают сразу все подсистемы и сами решают стоит ли им обрабатывать данное сообщение. Плюс подхода - просто и понятно, минус - сложно, в случае чего, отследить что пошло не так. **Orchestrated** подразумевает наличие **process manager**'а который собирает события с подсистем и на их основании создает **command messages** адресованные определенным подсистемам. Плюс подхода -  уменьшение зависимости между подсистемами, минус - **process manager** может стать слабым звеном.

**Message-driven** системы являются **Reactive** (== **responsive** + **resilient** + **elastic** + **message-driven**) системами, в отличие от систем основанных на императивном подходе, выполененных с помощью [[REST]], [[RPC]] или вызовов методов. 

Коммуникация между подсистемами происходит через **message bus** - своего рода очередь всех сообщений.  Однако в рамках одной подсистемы использовать коммуникацию через **message bus** не стоит. Например, компоненты одной подсистемы монут быть выполнены как **Actors**, каждый из которых получает и постит асинхронно сообщения (является **message-driven**). Таким образом компоненты тоже будут являться **Reactive** (так и построена **Domain Model of Actors**).

Однако, **message-driven** система может быть построена и с помощью **REST**, если есть запрос на использование популярных технологий. 

# Event Sourcing

Обычно в **domain-driven** системах нам нужно сохранять состояние всего [[Aggregate]]. Для этого используются [[ORM]]. Но бывают случаи, когда есть смысл сохранять не объекты, а их изменения. Такая практика называется **Event Sourcing**. Важно, что события не удаляются из истории. Так, например, для исправление ошибочного изменения создается новое изменение. Этот подход делает больно, когда:
- **Aggregates** претерпевают большие структурные изменения.
- В истории появляется ошибочное изменение
- Слишком большая история для реконструкции текущего состояния **Aggregate**

При использовании данного подхода следует использовать [[CQRS|CQRS (Command Query Responsibility Segregation)]]. 

# Serverless and Function as a Service

[[Serverless|Serverless system]] - система при которой поставщики облачных услуг берут на себя обеспечение работы сервера, снимая эту ответсвенность с пользователя.  

Плюсы такого подхода:
- Оплата производится только за время реальной активности приложения
- Возможность пользоваться сопутствующей уже настроенной инфраструктурой
- Позволяет уделить больше времени имплементации бизнес-логики

В **serverless systems** тоже подойдет [[Ports and Adapters]], но нужно стараться сделать систему **cloud-native** (по-максимому использующему готовую инфраструктуру, в том числе специально спроектированные базы данных и системы **messaging**).

Минусом может стать непозволительная задержка при **холодном старте** приложения.


